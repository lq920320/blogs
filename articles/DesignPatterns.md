## Java 深入浅出设计模式
tags: Java 设计原则 设计模式

### 六大设计原则

#### 1. 基础原则——开闭原则（Open-Closed Principle, OCP）

定义：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被拓展。从另外一个角度讲，就是所谓的“对可变性封装原则”，而此也意为着两点：
- 一种可变性不应当分散于很多代码片段中，而应当被封装到一个对象里面。同一种可变性的不同表象意味着同一个继承等级结构中的具体子类。
- 一种可变性不应当与另一种可变性混合在一起。类的设计应该具备特定的可变性而不是众多的可变性。

#### 2. 单一职责原则（Single Responsibility Principle, SRP）

定义：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

在构造对象时，应将对象的不同职责分离至多个类中，从而确保引起该类变化的原因只有一个。使用此原则可以提高内聚，降低耦合度。

#### 3. 里氏替换原则（Liskov Substitution Principle, LSP）

定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象。

该原则的具体应用体现在继承关系上，在实现继承时，子类必须能替换掉它们的基类。如果一个软件代码中使用的是基类的话那么也一定可以使用其子类，但反过来的
代换则可以不成立。

#### 4. 依赖倒转原则（Dependency Inversion  Principle, DIP）

定义：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型
声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，
否则将无法调用到在子类中增加的新方法。

在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进
行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。
      
#### 5. 接口隔离原则（Interface  Segregation Principle, ISP）

定义：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。其意图是不要强迫客户依赖于他们不需要的方法，应用接口将两者隔离。

在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离
原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。

#### 6. 迪米特法则（Law of Demeter, LoD）

定义：迪米特法则又称为最少知识原则(LeastKnowledge Principle, LKP)，是指一个软件实体应当尽可能少地与其他实体发生相互作用。

如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求
限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。

迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类：

 (1) 当前对象本身(this)；

 (2) 以参数形式传入到当前对象方法中的对象；

 (3) 当前对象的成员对象；

 (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；

 (5) 当前对象所创建的对象。

### 面向对象的23种设计模式

设计模式的优点如下：
- 复用解决方案。设计模式的主要思想就是“复用”，通过复用已经确认的设计，能够在解决问题的过程中使用最小的成本获得最大的效益，不用再为那些总是会重复
出现的问题设计解决方案。
- 设计模式将设计方法标准化。
- 设计模式可以可以提高个人和团队的设计能力。
- 设计模式使软件更容易修改和维护。其原因在于：这些模式都是久经考验的解决方案。

#### *创建型模式*
用于创建对象。对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，以便能够高效地创建对象就是创建型模式要探讨的问题。
#### 1. 工厂方法模式（Factory Method）

工厂方法模式定义了一个用户创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。

通用类图如下：

<img src='images/factory.png' />

#### 2. 抽象工厂模式（Abstract Factory）

抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。

通用类图如下：

<img src='images/abstrcat-factory.png' />

#### 3. 建造者模式（Builder Factory）

建造者模式将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。

通用类图如下：

<img src='images/builder.png' />

#### 4. 原型模式（Prototype）

原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。

通用类图如下：

<img src='images/prototype.png' />

#### 5. 单例模式（Singleton）

单例模式确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类成为单例类。

由定义可总结出三个要点：一是单例类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。

通用类图如下：

<img src='images/singleton.png' />

#### *结构性模式*
用于构建类间的关系。如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性，代码的健壮性、耦合性等。
#### 6. 适配器模式（Adapter）

适配器模式在编程过程中是一个经常用到的模式，它的作用是将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作
的那些类可以一起工作。

通用类图如下：

<img src='images/adapter.png' />

#### 7. 桥接模式（Bridge）

桥接模式将抽象部分与实现部分分离，使它们都可以独立变化。

通用类图如下：

<img src='images/bridge.png' />

#### 8. 代理模式（Proxy）

代理模式为其他对象提供一种代理以控制对这个对象的访问。 

普通代理通用类图如下：

<img src='images/proxy.png' />

动态代理通用类图如下：

<img src='images/dynamic-proxy.png' />

#### 9. 外观模式（Facade）

外观模式的意图是为了给系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

通用类图如下：

<img src='images/facade.png' />

#### 10. 装饰模式（Decorator）

装饰模式可以动态地给一个对象添加一些额外的职责。

在实际应用中，装饰模式通常用做给现有的类增加功能，可以根据应用的需要，对装饰模式的类进行任意顺序的包装，最后生成符合要求的对象。

通用类图如下：

<img src='images/decorator.png' />

#### 11. 组合模式（Composite）

组合模式将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。

通用类图如下：

<img src='images/composite.png' />

#### 12. 享元模式（Flyweight）

享元模式的意图是用共享技术有效地支持大量的细粒度对象。

通用类图如下：

<img src='images/flyweight.png' />

#### *行为性模式*
用于控制对象的行为。如果对象的行为设计得好，那么对象的行为就会更清晰，它们之间的协作效率就会更高。
#### 13. 命令模式（Command）

命令模式将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。

通用类图如下：

<img src='images/command.png' />

#### 14. 观察者模式（Observer）

观察者模式的意图是定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。

通用类图如下：

<img src='images/observer.png' />

#### 15. 责任链模式（Chain of Responsibility）

责任链模式使多个对象都有机会处理请求（Request），从而避免请求的送发者和接收者之间的耦合关系。该模式将这些对象连成一条链，并沿着这条链传递该请求，
直到有一个对象处理请求为止。 

通用类图如下：

<img src='images/response-chain.png' />

#### 16. 迭代器模式（Iterator）

迭代器模式提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部细节。

通用类图如下：

<img src='images/iterator.png' />

#### 17. 访问者模式（Visitor）

访问者模式定义一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。

通用类图如下：

<img src='images/visitor.png' />

#### 18. 状态模式（State）

状态模式允许对象在其内部状态改变时改变他的行为，对象看起来似乎改变了他的类一样。

通用类图如下：

<img src='images/state.png' />

#### 19. 备忘录模式（Memento）

备忘录模式可以在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后在需要时就可以将该对象恢复到原先保存的状态。 

通用类图如下：

<img src='images/memento.png' />

#### 20. 策略模式（Strategy）

策略模式的目的是定义一系列的算法，把它们一个个封装起来，使它们可以互相替换，从而使得算法可以独立于使用它们的客户而发生变化。

通用类图如下：

<img src='images/strategy.png' />

#### 21. 调停者模式（Mediator）

调停者模式（中介者模式）定义了一组对象之间的相互影响的行为的对象，这样可以使用松耦合的方式联系一组对象，避免对象之间互相显式地直接引用，从而当改变了某些对象之间
的关系时，就可以不影响其他的对象了。

通用类图如下：

<img src='images/mediator.png' />

#### 22. 模板方法模式（Template Method）

模板方法模式的设计意图是由抽象父类控制顶级逻辑，并把基本操作的实现推迟到子类中去实现，这是通过继承的手段来达到对对象的复用。

通用类图如下：

<img src='images/template-method.png' />

#### 23. 解释器模式（Interpreter）

解释器模式给定一种语言，定义它的文法标识，并定义一个解释器，然后这个解释器将使用该文法标识来解释语言中的句子。

通用类图如下：

<img src='images/interpreter.png' />
