### 第3章  权责让渡

函数式思维的好处之一，是能够将低层次细节（如垃圾收集）的控制权移交给运行时，从而消弭了一大批注定会发生的程序错误。开发者们可以一边熟视无睹地享受着最基本的抽象，比如内存，一边却会对更高层次的抽象感觉突兀。。然而不管层次高低，抽象的目的总是一样的：让开发者从繁琐的运作细节里解脱出来，去解答问题中非重复性的那些方面。


####  3.1 迭代让位于高阶函数

理解掌握的抽象层次永远要比日常使用的抽象层次更深一层。

程序员的工作效率依赖于抽象层，好比没有人会直接翻弄硬盘上或0或1磁盘记录来给计算机编程。抽象隐藏了繁杂的细节，只是有时候会连同重要的考虑因素一起隐藏掉。


#### 3.2 闭包

闭包(closure)是所有函数式语言都具备的一项平常特性，可是相关的论述却常常充斥着晦涩乃至神秘的字眼。
所谓闭包，实际上是一种特殊的函数，它在暗地里绑定了函数内部引用的所有变量。换句话说，这种函数（或方法）把它引用的所有东西都放在一个上下文里“包”了起来。

*Groovy语言中闭包绑定的简单示例*

```groovy
class Employee {
    def name, salary
}

def paidMore(amount) {
    return {Employee e -> e.salary > amount}
}

isHighPaid = paidMore(100000)
```
首先定义了一个简单的Employee类，类中带了两个字段。接着定义带有amount参数的paidMore函数，其返回值是一个以Employee实例为参数的代码块，或者叫闭包。
类型声明Employee可写可不写，这里写出来顺便起到文档的作用。接下来，我们给代码块传入参数值100000，并赋予isHighPaid的名称，于是数值100000就随着这一步赋值操作，永久地和代码块绑定在一起了。以后有员工数据被带入这个代码块求解的时候，它就可以拿绑定的数值作为标准去评判员工的工资高低。

*执行闭包*

```groovy
def Smithers = new Emplyee(name: "Fred", salary: 120000)
def Homer = new Employee(name: "Homer", salary: 80000)
println isHighPaid(Smithers)
println isHighPaid(Homer)
// true, false
```
本例创建了两笔员工数据，然后判断其工资是否达到标准线。闭包在生成的时候，会把引用的变量全部圈到代码块的作用域里，封闭、包围起来（故名闭包）。
闭包的每个实例都保有自己的一份变量取值，包括私有变量也是如此。也就是说，我们可以创建paidMore闭包的另一个实例，给它绑定另外的数值（当然实例的名字也要另取）。

*绑定另一个闭包*

```groovy
isHigherPaid = paidMore(200000)
println isHigherPaid(Smithers)
println isHigherPaid(Homer)
def Burns = new Employee(name: "Monty", salary: 1000000)
println isHigherPaid(Burns)
// false, false, true
```
闭包经常被函数式语言和框架当成是一种异地执行的机制，用来传递待执行的变换代码，如map()之类的高阶函数。在缺乏闭包特性的旧版Java平台上，Functional Java利用匿名内部类来模仿“真正的”闭包的某些行为，但语言的先天不足导致这种模仿是不彻底的。

*闭包的原理（Groovy示例）*
```groovy
def Cloure makeCounter() {
  def local_variable = 0
  return {return local_variable += 1}  // ①
}

c1 = makeCounter()  //②
c1()               // ③
c1()
c1()

c2 = makeCounter()     // ④

println "C1 = ${c1()}, C2 = ${c2()}"
// output:C1 = 4, C2 = 1 ⑤
```
- ①函数的返回值是一个代码块，而不是一个值
- ②c1现在只想代码块的一个实例
- ③调用c1将递增其内部变量，如果这个时候输出，其结果也会是1
- ④c2现在指向makeCounter()的一个全新实例，与其他实例没有关联
- ⑤每个实例的内部状态都是独立的，各自拥有一份local_variable

makeCounter()函数首先定义一个局部变量，明白无误地命名为local_variable，接着返回一个使用了该局部变量的代码块。注意makeCounter()函数的返回类型是Closure，而不是一个单穿的值。
代码块的工作仅仅是递增并返回其局部变量的值。方法中两次明确写出了return关键字，其实这两个地方Groovy都允许省略，不过那样的话，代码看起来就有些晦涩了。

为了演示makeCounter()函数的用法，我们给代码块分配了一个变量名c1，然后调用了三次。调用代码块的时候用到了Groovy提供的语法糖衣，也就是在代码块变量名后直接跟一对圆括号的写法（否则应该写成c1.call()）。接下来，我们第二次调用了makeCounter()，将返回的又一个代码块实例赋给变量c2.最后我们把c1和c2都调用了一次。
从运行结果来看，两个代码块实例都分别持有自己的一份local_variable变量。“闭包”这个名字来源于它创建*封闭上下文*的行为。虽然局部变量不是在代码块里面定义的，但只要代码块引用了该变量，两者就被绑定在一起，这种联系在代码块实例的全部生命期内都一直保持着。

从实现的角度来说，代码块实例从它被创建的一刻起，就持有其作用域内的一切事物的封闭副本。当代码块实例被垃圾收集的时候，它持有的引用也同时被回收。

闭包在这里表现出的函数式思维就是“让运行时去管理状态”。

**让语言去管理状态。**

闭包还是*推迟执行*原则的绝佳样板。我们把代码绑定到闭包之后，可以推迟到适当的时机再执行闭包。这个特点在很多场合都能发挥作用。例如必要的变量和函数可能并不在定义时的作用域里，要到执行的时候才准备好。那么我们把执行上下文放在闭包里保留起来，就可以等到正确的时机再完成执行。

命令式语言围绕状态来建立编程模型，参数传递是其典型特征。闭包作为一种对行为的建模手段，让我们把代码和上下文同时封装在单一结构，也就是闭包本身里面，像传统数据结构一样可以传递到其他位置，然后在恰当的时间和地点完成执行。

**抓住上下文，而非状态。**

#### 3.3 柯里化和函数的部分施用

柯里化（currying）和函数的部分施用（partial application）都是从数学里借用过来的编程语言技法。柯里化和函数部分施用都有能力操纵函数或方法的参数数目，一般是通过向一部分参数代入一个或多个默认值的办法来实现的（这部分参数被称为“固定参数”）。

##### 3.3.1  定义与辨析
乍看起来，柯里化和部分施用的使用效果是一样的。两者都可以创建有一部分预设参数值的函数。

柯里化指的是从一个多函数变成一连串单参数函数的变换。它描述的是变换的过程，不涉及变换之后对函数的调用。调用者可以决定对多少个参数实施变换，余下的部分将衍生为一个参数数目较少的新函数。

部分施用指通过提前代入一部分参数值，使一个多参数得意省略部分参数，从而转化为一个参数数目较少的函数。这种技法叫作“部分施用”，顾名思义，就是让函数先作用于其中一些参数，经过部分的求解，结果返回一个由余下参数构成签名的函数。

柯里化和部分施用都是在我们提供部分参数值之后，产出可以凭余下参数实施调用的一个函数。不同的地方在于，函数柯里化的结果是返回链条中下一个函数，而部分施用是把参数的取值绑定到用户在操作中提供的具体值上，因而产生一个“元数”（参数的数目）较少的函数。用元数大于二的函数来套一下这里的解释，它们之间的区别就会比较清楚了。

举个例子，函数process(x, y, z)完全柯里化之后将变成process(x)(y)(z)的形式，其中process(x)和process(x)(y)都是单参数的函数。
如果只对第一个参数柯里化，那么process(x)的返回值将是一个单参数的函数，而这个唯一的参数又接受另一个参数的输入。
而部分施用的结果直接是一个减少了元数的函数。如果在process(x, y, z)上部分施用一个参数，那么我们将得到还剩下两个参数的函数：process(y, z).

##### 3.3.2 Groovy的情况
Groovy通过curry()函数实现柯里化，这个函数来自Closure类。

*Groovy语言中的柯里化*

```groovy
def product = {x, y -> x * y}

def quadrate = product.curry(4)      //①
def octate = product.curry(8)        //②

println "4×4：${quadrate.call(4)}"   //③
println "8×5：${octate(5)}"          //④
```
- ①调用curry()来固定一个参数，返回结果是一个单参数的函数。
- ②octate()函数总是对传入的参数乘以8.
- ③quadrate()是一个单参数的函数，可以通过Closure类的call()方法来调用它。
- ④Groovy提供了一层语法 糖衣，可以让调用语句的写法更自然一些。

本例首先定义接受两个参数的代码块product。利用Groovy内建的curry()方法，在product的基础上构造出两个新的代码块，quadrate和octate。
Groovy为调用代码块提供了特别的便利，我们既可以执行call()方法，也可以使用Groovy在语言层面提供的语法糖衣，也就是在代码块的名称后面紧跟一对圆括号，参数则写在括号里。

curry()虽然叫这个名字，它在背后对代码块所做的事情其实属于函数的部分施用。尽管名不符实，但用它来模拟出柯里化的效果还是可行的。做法是通过连续的部分施用使函数变形为一连串单参数的函数，如下。

*Groovy语言中部分施用与柯里化的对比*

```groovy
def volume = {h, w, l -> h * w * l}
def area = volume.curry(1)
def lengthPA = volume.curry(1, 1)         //①
def lengthC = volume.curry(1).curry(1)    //②

println "参数取值为2×3×4的长方体，体积为${volume(2, 3, 4)}"
println "参数取值为3×4的长方形，面积为${area(3, 4)}"
println "参数取值为6的线段，长度为${lengthPA(6)}"
println "参数取值为6的线段，经柯里化函数求得的长度为${lengthC(4)}"
```
- ①部分施用
- ②柯里化

两种写法只有微妙的区别，最终的计算结果也完全相同，但如果你在一名函数式程序员面前不加区分地使用这两个名词，他一定会纠正你。很不幸，Groovy把这两个密切相关的概念混为一谈了。

函数式编程赋予我们另一套新的构造单元，代替以往命令式语言所使用的机制来完成相同的目标。这些构造单元之间的关系经过了细致的安排。复合（composition），是函数式语言拼组这些构造单元的一般方式。

##### 3.3.5 一般用途
1. 函数工厂

我们在传统面向对象编程中会用到工厂方法的场合，正适合柯里化（以及部分施用）表现它的才干。如下，Groovy实现的加法函数和递增函数。

```groovy
def adder = {x, y -> x + y}
def incrementer = adder.curry(1)

println "incrementer 7 : ${incrementer(7)}"   //8
```
例中从adder()函数派生出了incrementer函数。

2. Template Method模式

GoF模式集里面有一项Template Method（模板方法）模式。其用意是在固定的算法框架内部安排一些抽象方法，为后续的具体实现保留一部分的灵活性。部分施用和柯里化也可以起到相同的作用。部分施用技法注入当前已经确定的行为，留下未确定的参数给具体实现去发挥，其思路与模板方法这种面向对象的设计模式如出一辙。

第6章将会用一个例子来说明，若干模式（包括模板方法模式在内）怎样因为部分施用和其他函数式技法而失去了存在意义。

3. 隐含参数

当我们需要频繁调用一个函数，而每次的参数值都差不多的时候，可以运用柯里化来设置隐含参数。举个例子，我们在操作持久化框架的时候，每次都要在第一个参数里写上数据源的位置。而经过部分施用以后，就不需要反复地写出这个参数值了。

*运用部分施用技法设置隐含参数值*

```
(defn db-connect[data-source query params]
    ...)
    
(def dbc (partial db-connect "db/some-data-source"))

(dbc "select * from %1" "cust") 
```
dbc函数在操作数据的时候不需要在提供数据源，数据源已经自动设置好了。面向对象编程中“封装”概念的本质，也就是魔术般出现在每个函数里的隐含上下文this，我们可以在函数式编程中加以模拟，用柯里化的方式吧this传递给所有的函数，让this在使用这的面前隐藏起来。

#### 3.4 递归
递归，按照维基百科的定义，是“一种自相似的方式来重复事物的过程”。它也是我们想运行时托付操作细节的一个例子，而且和函数式编程有着极为密切的联系。
以具体的时间来说，递归是以一种带点计算机科学味道的方式来对一组事物进行迭代，让事物的集合反复对自身调用同样的方法，使集合随着每次迭代不断缩小，同时要始终小心地保证退出条件的有效性。
很多时候，我们的问题核心就是对一个不断变短的列表反复做同一件事。



## 第4章   用巧不用蛮
我们转换范式的收获，表现在费更少的力气完成更多的事情。很多函数式编程构造的目的只有一个：从频繁出现的场景中消灭掉烦人的实现细节。

### 4.1 记忆

“memoization”这个词是英国的人工智能研究者Donald Michie生造出来的，指的是在函数级别上对需求多次使用的值进行缓存的机制。
目前来说，函数式编程语言皮鞭都支持记忆特性，有些事直接内建在语言里，也有一些需要开发者自行实现，但实现起来相对容易。

记忆可以用在这样的场合。假设我们有一个反复调用的函数，需要挖掘它的性能潜力。增加一个内部缓存是很容易想到的方案。每次我们根据一组特定的参数求得结果之后，就用参数值做查找用的键，把结果缓存起来。以后当函数又遇到相同参数的时候，就不需要重新计算一遍了，可以直接返回缓存的结果。
这种缓存函数计算结果的做法，是计算机科学里一种典型的折中方案：用更多的内存（我们一般不缺内存）去换取长期来说更高的效率。

只有纯（pure）函数才可以适用于缓存技术。纯函数是没有副作用的函数：它不引用其他值可变的类字段，除返回值之外不设置其他的变量，其结果完全由输入参数决定。
很显然，只有在函数对同样一组参数总是返回相同结果的前提下，我们才可以放心地使用缓存起来的结果。

#### 4.1.1 缓存
缓存是很常见的需求（同时也是制造晦涩错误的源头）。我们首先分两种情况去剖析函数缓存的用法，一种是类内部缓存，另一种是外部调用。
然后详细说明缓存的两种实现方式，一种是手工进行状态管理，另一种是记忆机制。

**1. 方法级别的缓存**

上一章判定数字归属的工作由Classifier类负责，我们可以想见其中一种典型的用例，是让同一个数字把几个分类方法都跑一遍。如下代码：

```
if(Classifier.isPerfect(n)) print "!"
else if(Classifier.isAbundant(n)) print "+"
else if(Classifier.isDeficient(n)) print "-"
```
按照先前的实现，被调用到的每一个分类方法，都只能够重新计算真约数和。这种情况恰好是*类内部缓存*的应用范本：在常规的使用中，每检查一个数字，都要调用sumOfFactors()方法若干次。
原来的实现方案对于一个频繁出现的用例来说过于低效。

**2. 缓存求和结果**

再利用已有的工作成果是提高代码效率的办法之一。因为真约数和的计算成本高昂，所以我们希望每个数字只计算一次。

```groovy
/**
* 缓存求和结果
*/
class ClassifierCachedSum {
  private sumCache = [:]
  def sumOfFactors(number){
    if (! sumCache.containsKey(number)){
      sumCache[number] = factorsOf(number).sum()
    }
  }
  return sumCache[number]
  
}
//其余代码不变
```

本例增加一个和类一起初始化的散列sumCache。在sumOfFactors()方法中，我们首先检查传入的参数是否已经在缓存里有对应的计算结果，有的话直接返回，否则才会执行昂贵的计算，并在返回之前把求和结果置入缓存。

这种情况是*外部缓存*的范本：调用方受益于缓存起来的结果，才有了第二次运行的高速。

缓存求和结果成绩斐然，但也付出了一些代价。ClassifierCachedSum不可以在纯粹有静态方法组成。类中的缓存就代表类有了状态，所有与缓存打交道的方法都不可以是静态的，于是产生了更多的连锁效应。
缓存可以提高性能，但缓存有代价：它提高了代价的非本质复杂性和维护负担。

**3. 缓存一切结果**

既然缓存求和的结果大大提高了代码的性能，何不试试把所有可能出现的中间结果都缓存起来呢？

```groovy
//缓存所有的计算结果
class ClassifierCached {
  private sumCache = [:], factorCache = [:]
  
  def sumOfFactors(number) {
    if (! sumCache.containsKey(number))
      sumCache[number] = factorsOf(number).sum()
    sumCache[number]
  }
  
  def isFactor(number, potential){
    number % potential == 0
  }
  
  def factorsOf(number) {
    if (!factorCache.containsKey(number))
      factorCache[number] = (1..number).findAll {isFactor(number,it)}
    factorCache[number]
  }
  
  def isPerfect(number) {
    sumOfFactors(number) == 2 * number
  }
  
  def isAbundant(number) {
    sumOfFactors(number) > 2 * number
  }
  
  def isDeficient(number) {
    sumOfFactors(number) < 2 * number
  }
}
```
ClassifierCached类除了缓存真约数的计算结果，还缓存了每个数的约数。
但是当我们把测试的取值范围增加8000个数字，马上就变成下面的结果：
```
java.lang.OutOfMemoryError: Java head space
```
这几次测试告诉我们，负责编写缓存代码的开发者不仅要顾及代码的正确性，连它的执行环境也要考虑在内。所谓“不确定因素”说的就是这样的东西：代码中的状态，开发者不仅要费心照应它，还要条分缕析它的一切明暗牵连。好在很多语言已经有了突破困境的办法，例如记忆机制。

#### 4.1.2 引入“记忆”

函数式编程费了很大力气来遏制不确定因素，并为此在运行时内建了许多重用机制。“记忆”是其中的一种特性，它作为编程语言的固有设施，自动地缓存重复出现的函数返回值。

Groovy语言记忆一个函数的办法是，先将要记忆的函数定义成闭包，然后对该闭包执行memoize()方法来获得一个新函数，以后我们调用这个新函数的时候，其结果就会被缓存起来。

“记忆一个函数”这件事情，运用了所谓的“元函数”技法：我们操纵的对象是函数本身，而非函数的结果。Groovy把记忆特性内建在它的Closure类里面，其他语言各有各的实现方式。

为了让sumOfFactors()得到像上一节“缓存求和结果”那样的缓存能力，我们记忆了sumOfFactors()方法，如下例：

```groovy
//记忆求和结果
package com.nelford.fl.memoization

class ClassifiermemoizedSum {
  def static isFactor(number, potential){
    return number % potential == 0
  }
  
  def static factorsOf(number) {
    (1..number).findAll {i -> isFactor(number, i)}
  }
  
  def static sumFactors = { number ->
    factorsOf(number).inject(0, {i, j -> i + j})
  }
  def static sumOfFactors = sumFactors.memoize()
  
  def static isPerfect(number) {
    sumOfFactors(number) == 2 * number
  }
  
  def static isAbundant(number) {
    sumOfFactors(number) > 2 * number
  }
  
  def static isDeficient(number) {
    sumOfFactors(number) < 2 * number
  }
}
```
按照代码块的格式（注意看=和参数的写法）来实现sumFactors()方法。方法本身平平无奇，说不定可以直接在哪个库里找到现成的。未来记忆sumFactors()，我们对它调用了memoize()方法，并将返回的新函数命名为sumOfFactors。

```groovy
//记忆所有计算结果
package com.nealford.ft.memization

class Classifiermemoized {
  def static dividesBy = {number, potential -> 
    number % potential == 0
  }
  def static isFactor = dividesBy.memoize()
  
  def static factorsOf(number) {
    (1..number).findAll{ i -> isFactor.call(number, i)}
  }
  
  def static sumFactors = { number ->
    factorsOf(number).inject(0, {i, j -> i + j})
  }
  def static sumOfFactors = sumFactors.memoize()
  
  def static isPerfect(number) {
    sumOfFactors(number) == 2 * number
  }
    
  def static isAbundant(number) {
    sumOfFactors(number) > 2 * number
  }
    
  def static isDeficient(number) {
    sumOfFactors(number) < 2 * number
  }
}
```
扩大记忆范围拖慢了第一次运行的速度，但后续运行的速度是所有版本中最快的——但这只是数据量很小的情况。
随着数据量变大，它的性能也像命令式缓存版本那样急剧下滑。事实上当数据量达到8000的时候，就出现了内存不足。命令式的版本要想防范这种陷阱，需要小心地查看警戒条件，注意执行环境是否超出安全范围——命令式编程的不确定因素又一次出现在我们面前。
相比之下，通过记忆方式实现的上例修正起来十分简单，只需要在函数的层次上做改动。修改后的记忆版本可以轻松应付10000条数据量。我们只需要用memoizeAtMost(1000)方法代替原来的memoize()。

表4-6：Groovy提供的几个记忆方法

| 方法 | 说明 |
| -------- | -------- |
|memoize()   |  将闭包转化为带缓存的实例|  
|memoizeAtMost()   |  将闭包转化为带缓存的实例，且规定了缓存的数量上限| 
|memoizeAtLeast()  |  将闭包转化为带缓存的实例，缓存大小可自动调整，且规定了缓存的数量下限|
|memoizeBetween()  |  将闭包转化为带缓存的实例，缓存大小可自动调整，且规定了缓存的数量上限和下限|

在命令式的思路下，开发者就是代码的主人（以及一切责任的承担者）。而函数式语言的思路是，为了操纵一些标准的构造，我们来制作一些通用的机件，有时候还在机件上设置若干调节旋钮（
也就是函数的不同变体和参数的不同组合）。函数是语言的基本元素，因此函数层面上的优化会附带产生功能的提升。实际上，我们写出来的缓存绝不可能比语言设计者产生的更高效，因为语言设计者可以无视他们给语言订的规矩：开发者无法触碰的底层设施，不过是语言设计者手中的玩物，他们拥有的优化手段和空间是“凡人”无法企及的。
但我们将缓存等问题交托给语言，不仅仅是因为它的效率更高，更因为我们从此可以在更高的层次上去思考问题。

*语言设计者实现出现的机制总是比开发者自己做的效率更高，因为他们可以不受语言本身的限制。*

手工建立缓存的工作不算复杂，但它给代码增加了状态的影响和额外的复杂性。而借助函数式语言的特性，例如记忆，我们可以在函数级别上完成缓存工作，只需要微不足道的改动，就能取得比命令式做法更好的效果。
在函数式编程消除了不确定因素之后，我们得以专注解决真正的问题。

当然，我们不需要先写好类，再往上添加及一层。memoize()和它的兄弟们都是定义在Closure类里面的库函数。

被记忆的内容应该是值不可变的，这一点非常重要。如果被记忆的函数在求解器返回结果的时候，需要依赖参数以外的任何因素，那么它的输出是不可预料的。如果被记忆的函数有副作用，那么当它直接返回缓存结果的时候，就跳过了产生副作用的那部分代码，没有执行。

*请保证所有被记忆的函数：*
- 没有副作用
- 不依赖任何外部信息

### 4.2 缓求值

缓求值（lazy evaluation）是函数式编程语言常见的一种特性，指尽可能地推迟求解表达式。缓求值的集合不会预先算好所有的元素，而是在用到的时候才落实下来，这样做有几个好处。
第一，昂贵的运算只有到了绝对必要的时候才执行。
第二，我们可以建立无限大的集合，只要一直接到请求，就一直送出元素。
第三，按缓求值的方式来使用映射、筛选等函数式的概念，可以产生更高效的代码。

```
//演示“非严格求值”的伪代码
print length([2+1, 3*2, 1/0, 5-4])
```

这段代码会得到怎样的执行结果，取决于所有编程语言的一项性质：它是*严格求值*（strict）的，还是*非严格求值*（non-strict）的（也叫缓求值，lazy）。
在严格求值的编程语言里，执行（甚至编译）这段代码，会因为列表中的第三个元素而发生“零被除”异常。而在非严格求值的语言里，它会得出4的结果，准确地报告列表元素的数目。
毕竟我们调用的方法叫作length()，而不叫lengthAndThrowExceptionWhenDivByZero()！常用的费严格求值语言有Haskell.Java虽然不属于这个阵营，但缓求值的思路仍然可以给我们带来好处。

#### 4.2.1 Java语言下的缓求值迭代子

我们的探索可以从*素数*（只能被1和它本身整除的自然数）类开始。

```java
//寻找素数，Java实现

```



















